/**
 * Terminal reporter - formats output for console
 */

import chalk from 'chalk';
import { ExecutionData, StaticInventory, FunctionInfo } from '../runtime/types';

export interface ReportOptions {
  verbose?: boolean;
  showAll?: boolean;
}

/**
 * Generate terminal report comparing inventory vs execution
 */
export function generateReport(
  inventory: StaticInventory,
  execution: ExecutionData,
  options: ReportOptions = {}
): void {
  console.log('\n' + chalk.bold.cyan('ðŸ“Š siko Signal Analysis Report'));
  console.log(chalk.gray('â”€'.repeat(60)) + '\n');

  // Summary
  console.log(chalk.bold('Summary:'));
  console.log(`  Total functions found: ${chalk.cyan(inventory.totalFunctions)}`);
  console.log(`  Functions executed: ${chalk.green(execution.totalFunctions)}`);
  
  const unusedCount = inventory.totalFunctions - execution.totalFunctions;
  const coveragePercent = inventory.totalFunctions > 0
    ? ((execution.totalFunctions / inventory.totalFunctions) * 100).toFixed(1)
    : '0';
  
  console.log(`  Functions not executed: ${chalk.red(unusedCount)}`);
  console.log(`  Execution coverage: ${chalk.yellow(coveragePercent + '%')}\n`);

  // Find unused functions
  const executedIds = new Set(Object.keys(execution.executions));
  const unusedFunctions = inventory.functions.filter(f => !executedIds.has(f.id));
  const usedFunctions = inventory.functions.filter(f => executedIds.has(f.id));

  // Show unused functions
  if (unusedFunctions.length > 0) {
    console.log(chalk.bold.red('âŒ Unused Functions:'));
    
    // Group by file
    const byFile = groupByFile(unusedFunctions);
    
    for (const [file, functions] of Object.entries(byFile)) {
      console.log(chalk.gray(`\n  ${file}:`));
      functions.forEach(func => {
        console.log(`    ${chalk.red('â—')} ${func.name} ${chalk.gray(`(line ${func.line})`)}`);
      });
    }
    console.log();
  } else {
    console.log(chalk.bold.green('âœ… All functions were executed!\n'));
  }

  // Show used functions if verbose
  if (options.verbose && usedFunctions.length > 0) {
    console.log(chalk.bold.green('âœ… Executed Functions:'));
    
    const byFile = groupByFile(usedFunctions);
    
    for (const [file, functions] of Object.entries(byFile)) {
      console.log(chalk.gray(`\n  ${file}:`));
      functions.forEach(func => {
        const count = execution.executions[func.id] || 0;
        console.log(`    ${chalk.green('â—')} ${func.name} ${chalk.gray(`(${count}x)`)}`);
      });
    }
    console.log();
  }

  // Execution statistics
  if (options.showAll) {
    console.log(chalk.bold('Execution Statistics:'));
    console.log(`  Total executions: ${chalk.cyan(execution.totalExecutions)}`);
    
    // Find most called function
    let maxCalls = 0;
    let maxFunction = '';
    
    for (const [id, count] of Object.entries(execution.executions)) {
      if (count > maxCalls) {
        maxCalls = count;
        maxFunction = id.split(':')[0];
      }
    }
    
    if (maxFunction) {
      console.log(`  Most called: ${chalk.cyan(maxFunction)} ${chalk.gray(`(${maxCalls}x)`)}`);
    }
    console.log();
  }

  console.log(chalk.gray('â”€'.repeat(60)));
  console.log(chalk.dim('Generated by siko - Runtime Signal Analyzer\n'));
}

/**
 * Group functions by file
 */
function groupByFile(functions: FunctionInfo[]): Record<string, FunctionInfo[]> {
  const grouped: Record<string, FunctionInfo[]> = {};
  
  for (const func of functions) {
    if (!grouped[func.file]) {
      grouped[func.file] = [];
    }
    grouped[func.file].push(func);
  }
  
  // Sort functions within each file by line number
  for (const file in grouped) {
    grouped[file].sort((a, b) => a.line - b.line);
  }
  
  return grouped;
}

/**
 * Simple summary without full report
 */
export function printSummary(
  inventory: StaticInventory,
  execution: ExecutionData
): void {
  const unusedCount = inventory.totalFunctions - execution.totalFunctions;
  const coveragePercent = inventory.totalFunctions > 0
    ? ((execution.totalFunctions / inventory.totalFunctions) * 100).toFixed(1)
    : '0';

  console.log(chalk.bold('\nðŸ“Š Quick Summary:'));
  console.log(`  ${chalk.cyan(inventory.totalFunctions)} functions found`);
  console.log(`  ${chalk.green(execution.totalFunctions)} executed`);
  console.log(`  ${chalk.red(unusedCount)} unused`);
  console.log(`  ${chalk.yellow(coveragePercent + '%')} coverage\n`);
}